#!/usr/bin/env node

/** 
 * Compared to other generators, Igloo generator has a different
 * approach.
 * 
 * 1. The user can build an Igloo using 'igloo create' command (or
 *    a command like 'igloo create helmet gulp' to create an Igloo
 *    with 'helmet' and 'gulp' packages preinstalled).
 * 
 * 2. The Igloo will contain all the examples and packages.
 *
 * 3. The user will be able to add and remove packages later using
 *    './bin/igloo add' and './bin/igloo remove' commands executed
 *    on the created Igloo. (As long as Igloo markers aren't
 *    deleted)
 *
 *    Well, now you can just use 'igloo' command to add/remove
 *    packages from any Igloo you've created.
 *
 **/

var program = require('commander')
var mkdirp = require('mkdirp')
var fs = require('fs')
var path = require('path')
var pkg = require('../package.json')
var ncp = require('ncp').ncp


var version = pkg.version;
var mainPath = path.dirname(__dirname)
var cwd = process.cwd()


// show help

program
  .version(version)
  .usage('[--add/--clone] [dir] [package list]')
  .option('--add', 'add packages to current Igloo')
  .option('--remove', 'remove packages')
  .option('--create', 'creates a new Igloo instance (with additional packages if you want)')
  .parse(process.argv)

// initialize


if(program.add){

  if(path.basename(path.dirname(path.dirname(__dirname))) !== 'node_modules'){
    addPackages(path.dirname(__dirname), program.args)

  }else{
    if(fs.existsSync(path.join(cwd, 'igloo.js'))){
      // we're in an igloo dir, just install stuff to that package
      addPackages(cwd, program.args)

    }else{
      // no way!
      console.log('You cannot install packages to global Igloo installation,')
      console.log('use \'create\' command to build your own Igloo.')
    }
  }

}else if(program.remove){

  if(path.basename(path.dirname(path.dirname(__dirname))) !== 'node_modules'){
    removePackages(path.dirname(__dirname), program.args)
  
  }else{
    if(fs.existsSync(path.join(cwd, 'igloo.js'))){
      // we're in an igloo dir, just remove packages from that
      removePackages(cwd, program.args)

    }else{
      // again, no way!
      console.log('You cannot remove packages from global Igloo installation,')
      console.log('use \'create\' command to build your own Igloo.')
    }
  }

}else if(program.create){

  var destinationPath = program.args.shift() || '.';
  var appName = path.basename(path.resolve(destinationPath));

  // clone project

  cloneProject(path.dirname(__dirname), program.args, destinationPath, function(){
    addPackages(destinationPath, program.args)
  })


}else{
  program.help();
}


/**
 * Validate package by decoding patches and
 * comparing those with the Igloo config etc.
 */
function validatePackage(base, packageName){
  // todo: do patch/js validations
  return true
}


/**
 * Go through all the requested packages and install
 * them if all the packages are valid.
 */
function addPackages(base, packageList){

  console.log('Adding packages...')

  // check everything before actually making changes

  for(var i=0; i<packageList.length; i++){
    if(!validatePackage(base, packageList[i])){
      abort('Found invalid packages in the list');
      break;
    }
  }

  // add packages

  for(var i=0; i<packageList.length; i++){
    if(!addPackage(base, packageList[i])){
      abort('Error adding package: ' + packageList[i]);
      break;
    }
  }

}

/**
 * Go through all the requested packages and remove
 * them if all the packages are valid.
 *
 * Hmm, maybe we don't need to validate them here?
 */
function removePackages(base, packageList){

  console.log('Removing packages...')

  // check everything before actually making changes

  for(var i=0; i<packageList.length; i++){
    if(!validatePackage(base, packageList[i])){
      abort('Found invalid packages in the list');
      break;
    }
  }

  // remove packages

  for(var i=0; i<packageList.length; i++){
    if(!removePackage(base, packageList[i])){
      abort('Error removing package: ' + packageList[i]);
      break;
    }
  }

}



/**
 * Install package to current Igloo mentioned in
 * 'base' parameter.
 */
function addPackage(base, packageName){
  var packagePath = path.join(base, './packages/' + packageName)
  var basePackage = JSON.parse(fs.readFileSync(path.join(base, './package.json'), 'utf8'))
  var packageData = {}

  // add dependencies

  packageData = JSON.parse(fs.readFileSync(path.join(packagePath, './package.json'), 'utf8'))

  if(packageData.dependencies || packageData.devDependencies){
    for(key in packageData.dependencies){

      // todo: instead of this, implement a way to
      // compare package versions with semver and update
      // if needed

      if(!basePackage.dependencies[key]){
        basePackage.dependencies[key] = packageData.dependencies[key]
      }
    }

    for(key in packageData.devDependencies){

      if(!basePackage.devDependencies)
        basePackage.devDependencies = {}

      if(!basePackage.devDependencies[key]){
        basePackage.devDependencies[key] = packageData.devDependencies[key]
      }
    }

    fs.writeFileSync(path.join(base, './package.json'), JSON.stringify(basePackage, null, 2))
    console.log(color('yellow', '* ./package.json'))
  }

  // create new files

  if(packageData.files){
    for(var i=0; i<packageData.files.length; i++){
      var packageFile = packageData.files[i]

      mkdir(path.join(base, packageFile.destination))

      fs.createReadStream(path.join(packagePath, './new/' + packageFile.source))
        .pipe(fs.createWriteStream(path.join(base, packageFile.destination, './' + packageFile.source)))

      console.log(color('green', '+ ' + packageFile.source))
    }
  }

  // patching

  var patchData = fs.readFileSync(path.join(packagePath, './patch.js'), 'utf8')
  var cPatchData = patchData
  var searchIndex = 0
  var lastFunc = ''
  var PATCH_CODE = '//-- package.add('

  // search for each patch

  for(;;searchIndex++){
    var pos = cPatchData.indexOf(PATCH_CODE)

    if(pos === -1){
      if(searchIndex)
        addPatch(cPatchData, lastFunc)
      break;

    }else{
      if(searchIndex)
        addPatch(cPatchData.substr(0, pos), lastFunc)
    }

    var cmdEnd = cPatchData.substr(pos).indexOf(') --//') + ')'.length

    lastFunc = cPatchData.substr(pos + PATCH_CODE.length, cmdEnd - (PATCH_CODE.length))

    cPatchData = cPatchData.substr(pos + cmdEnd + ' --//'.length)

  }

  function addPatch(str, func){
    str = str.trim()

    var params = func.split(',');
    for(var i=0; i<params.length; i++)
      params[i] = params[i].trim().replace (/(^')|('$)/g, '')

    if(params.length === 3){

      var fileContent = fs.readFileSync(path.join(base, params[0]), 'utf8')
      var markerString = '//-- igloo.patch.marker: ' + params[1] + ' --//'
      var indent = '  ', indentPos
      var newLine = '\n'

      // get new line format (unix/windows/...)

      if(fileContent.indexOf('\r\n') !== -1) newLine = '\r\n'
      else if(fileContent.indexOf('\n\r') !== -1) newLine = '\n\r'


      // calculate indent at package marker

      indentPos = fileContent.indexOf(markerString)

      if(indentPos !== -1){
        var t  = fileContent.substr(0, indentPos)
        var sp = t.lastIndexOf(newLine)

        if(sp !== -1){
          indent = t.substr(sp + newLine.length, indentPos - sp - newLine.length)
        }
      }

      // set new indent to patch content

      str = str.replace(/\r\n|\n\r|\n/g, newLine + indent)

      // apply new patch and add markers

      if(fileContent.indexOf('//-- igloo.patch.start: ' + packageName + ', ' + params[2] + ' --//') === -1){

        fileContent = fileContent.replace(markerString, markerString + newLine + indent +
          '//-- igloo.patch.start: ' + packageName + ', ' + params[2] + ' --//' + newLine + indent + str + newLine + indent +
          '//-- igloo.patch.end: '   + packageName + ', ' + params[2] + ' --//')

        fs.writeFileSync(path.join(base, params[0]), fileContent, 'utf8')
        console.log(color('yellow', '* ' + params[0]))
      }else{
        console.log('  ' + params[0] + ' already updated')
      }
    }
  }

  console.log(color('green', 'Added ' + packageName + ' package.'))

  if(packageData.note)
    console.log(color('cyan', 'Notes (from ' + packageName + '): ' + packageData.note))
  return true
}


/**
 * Remove package to current Igloo mentioned in
 * 'base' parameter.
 * todo: think of a better way to handle package.json clean up
 */
function removePackage(base, packageName){
  var packagePath = path.join(base, './packages/' + packageName)
  var basePackage = JSON.parse(fs.readFileSync(path.join(base, './package.json'), 'utf8'))
  var packageData = {}

  // show a list of dependencies to remove

  packageData = JSON.parse(fs.readFileSync(path.join(packagePath, './package.json'), 'utf8'))

  console.log('Following dependencies were added by ' + packageName +
    ' please remove these manually')

  if(packageData.dependencies){
    for(key in packageData.dependencies){
        console.log(color('yellow', '* ' + key))
    }
  }

  if(packageData.devDependencies){
    for(key in packageData.devDependencies){
        console.log(color('yellow', '* ' + key + ' [dev]'))
    }
  }

  console.log('')

  // remove new files

  if(packageData.files){
    for(var i=0; i<packageData.files.length; i++){
      var packageFile = packageData.files[i]

      unlink(path.join(base, packageFile.destination, './' + packageFile.source))

      console.log(color('red', '- ' + packageFile.source))
    }
  }

  // remove patches

  var patchData = fs.readFileSync(path.join(packagePath, './patch.js'), 'utf8')
  var cPatchData = patchData
  var searchIndex = 0
  var lastFunc = ''
  var PATCH_CODE = '//-- package.add('

  // search for each patch

  for(;;searchIndex++){
    var pos = cPatchData.indexOf(PATCH_CODE)

    if(pos === -1){
      if(searchIndex)
        removePatch(cPatchData, lastFunc)
      break;

    }else{
      if(searchIndex)
        removePatch(cPatchData.substr(0, pos), lastFunc)
    }

    var cmdEnd = cPatchData.substr(pos).indexOf(')') + ')'.length

    lastFunc = cPatchData.substr(pos + PATCH_CODE.length, cmdEnd - (PATCH_CODE.length))

    cPatchData = cPatchData.substr(pos + cmdEnd)

  }

  function removePatch(str, func){
    str = str.trim()

    var params = func.split(',');
    for(var i=0; i<params.length; i++)
      params[i] = params[i].trim().replace (/(^')|('$)/g, '')

    if(params.length === 3){

      var fileContent = fs.readFileSync(path.join(base, params[0]), 'utf8')
      var startMarker = '//-- igloo.patch.start: ' + packageName + ', ' + params[2] + ' --//'
      var endMarker   = '//-- igloo.patch.end: '   + packageName + ', ' + params[2] + ' --//'
      var patchStart = 0;
      var patchEnd = 0;

      // apply new patch and add markers

      patchStart = fileContent.indexOf(startMarker)
      if(patchStart === -1) return false

      patchEnd = fileContent.indexOf(endMarker)
      if(patchEnd === -1) return false

      fileContent = fileContent.substr(0, patchStart) + fileContent.substr(patchEnd + endMarker.length)

      fs.writeFileSync(path.join(base, params[0]), fileContent, 'utf8')
      console.log(color('yellow', '* ' + params[0]))
    }
  }

  console.log(color('green', 'Removed ' + packageName + ' package.'))
  return true
}

/**
 * Create a new Igloo using the current one.
 */
function cloneProject(base, packageList, destination, callback){

  console.log('Building a new Igloo...')

  mkdir(destination)

  ncp.limit = 32;

  ncp(base, destination, {filter: 
      function(name){
        if(name.indexOf('igloo/.git/') !== -1)
          return false
        return true
      }},
      function (err) {

    if (err)
      return console.error(err)

    console.log(color('green', 'Foundation is ready, installing packages...'))

    if(callback)
      callback()
  });


}




/* supporting functions -------------------------*/


function mkdir(dirPath){
  if(!fs.existsSync(dirPath)){
    mkdirp.sync(dirPath, '0755')
  }
}

function unlink(dirPath){
  if(fs.existsSync(dirPath)){
    fs.unlinkSync(dirPath)
  }
}

function color(cl, text){

  // from colors package (https://github.com/Marak/colors.js)
  var styles = {
    //styles
    'bold'      : ['\x1B[1m',  '\x1B[22m'],
    'italic'    : ['\x1B[3m',  '\x1B[23m'],
    'underline' : ['\x1B[4m',  '\x1B[24m'],
    'inverse'   : ['\x1B[7m',  '\x1B[27m'],
    'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
    //text colors
    //grayscale
    'white'     : ['\x1B[37m', '\x1B[39m'],
    'grey'      : ['\x1B[90m', '\x1B[39m'],
    'black'     : ['\x1B[30m', '\x1B[39m'],
    //colors
    'blue'      : ['\x1B[34m', '\x1B[39m'],
    'cyan'      : ['\x1B[36m', '\x1B[39m'],
    'green'     : ['\x1B[32m', '\x1B[39m'],
    'magenta'   : ['\x1B[35m', '\x1B[39m'],
    'red'       : ['\x1B[31m', '\x1B[39m'],
    'yellow'    : ['\x1B[33m', '\x1B[39m'],
    //background colors
    //grayscale
    'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
    'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
    'blackBG'     : ['\x1B[40m', '\x1B[49m'],
    //colors
    'blueBG'      : ['\x1B[44m', '\x1B[49m'],
    'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
    'greenBG'     : ['\x1B[42m', '\x1B[49m'],
    'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
    'redBG'       : ['\x1B[41m', '\x1B[49m'],
    'yellowBG'    : ['\x1B[43m', '\x1B[49m']
  }

  var cStyle = styles[cl]

  if(cStyle)
    return cStyle[0] + text + cStyle[1]
  else
    return text

}


// exit
function abort(str) {
  console.error(str);
  process.exit(1);
}